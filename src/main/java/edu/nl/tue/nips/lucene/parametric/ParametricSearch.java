package edu.nl.tue.nips.lucene.parametric;

import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.store.FSDirectory;

/*
 * implementation of parametric search
 */
public class ParametricSearch
{
	Map<String, String> params;
	String author;
	String bYear;
	String eYear;
	String topic;
	String mix;

	//initialize the query parameters
	public ParametricSearch(Map<String, String> params)
	{
		// TODO Auto-generated constructor stub
		this.params = params;
	}

	//check if any para is defined
	public boolean check()
	{
		if (!this.params.containsKey("author") && !this.params.containsKey("bYear") && !this.params.containsKey("eYear")
				&& !this.params.containsKey("topic"))
			return false;
		else
		{
			this.author = this.params.get("author");
			this.bYear = this.params.get("bYear");
			this.eYear = this.params.get("eYear");
			this.topic = this.params.get("topic");
			this.mix = this.params.get("mix");
			return true;
		}
	}

	public List<Integer> compute() throws IOException, ParseException
	{
		if (!check())
			return null;
		
		// read the index
		IndexReader reader = DirectoryReader.open(FSDirectory.open(Paths.get("iresource//paperindex")));
		IndexSearcher searcher = new IndexSearcher(reader);

		// calculate all papers written by a specific author
		List<Integer> byAuthor = new ArrayList<Integer>();
		if (this.author != null)
			byAuthor.addAll(filter(searcher, this.author, "name"));

		// calculate all papers belong to any topic
		List<Integer> byTopic = new ArrayList<Integer>();
		if (this.topic != null)
			byTopic.addAll(filter(searcher, this.topic, "topicid"));

		// calculate all papers written between a time period
		List<Integer> byYear = new ArrayList<Integer>();
		if (this.bYear != null || this.eYear != null)
		{
			if (this.bYear == null)
				this.bYear = "1987";
			if (this.eYear == null)
				this.eYear = "2016";
			for (int i = Integer.parseInt(this.bYear); i <= Integer.parseInt(this.eYear); i++)
				byYear.addAll(filter(searcher, "" + i, "years"));
		}

		//mix the papers according to the rule
		return mixFilter(this.mix, byAuthor, byTopic, byYear);
	}

	//query template for different parameters
	public List<Integer> filter(IndexSearcher searcher, String param, String paramField)
			throws ParseException, IOException
	{
		List<Integer> ids = new ArrayList<Integer>();
		
		Analyzer analyzer = new StandardAnalyzer();
		QueryParser parser = new QueryParser(paramField, analyzer);
		Query query = parser.parse(param);
		TopDocs hits = searcher.search(query, 6560);
		ScoreDoc[] scoreDocs = hits.scoreDocs;
		for (ScoreDoc scoreDoc : scoreDocs)
		{
			ids.add(Integer.parseInt(searcher.doc(scoreDoc.doc).get("id")));
		}
		return ids;

	}

	/*
	 * mix the results generated by different parameters
	 * if mix is and, then the result needs to fulfill all of the rules
	 * if mix is or, then the reuslt needs to fulfill one of the rules
	 */
	public List<Integer> mixFilter(String type, List<Integer> byAuthor, List<Integer> byTopic, List<Integer> byYear)
	{
		if (type.equals("or"))
		{
			Set<Integer> set = new HashSet<Integer>();
			for (Integer i : byAuthor)
				set.add(i);
			for (Integer i : byTopic)
				set.add(i);
			for (Integer i : byYear)
				set.add(i);
			return new ArrayList<Integer>(set);
		}
		else if (type.equals("and"))
		{
			List<Integer> list = new ArrayList<Integer>();
			if (this.author != null)
			{
				if (this.bYear == null && this.eYear == null && this.topic == null)
				{
					return byAuthor;
				}
				else if (this.bYear == null && this.eYear == null && this.topic != null)
				{
					for (Integer i : byAuthor)
					{
						if (byTopic.contains(i))
							list.add(i);
					}
				}
				else if (this.topic == null && (this.bYear != null && this.eYear != null))
				{
					for (Integer i : byAuthor)
					{
						if (byYear.contains(i))
							list.add(i);
					}
				}
				else
				{
					for (Integer i : byAuthor)
					{
						if (byYear.contains(i) && byTopic.contains(i))
							list.add(i);
					}
				}
			}
			else if (this.topic != null)
			{
				if (this.bYear == null && this.eYear == null)
					return byTopic;
				for (Integer i : byTopic)
				{
					if (byYear.contains(i))
						list.add(i);
				}
			}
			else if (this.eYear != null || this.bYear != null)
			{
				return byYear;
			}
			return list;
		}
		return null;
	}
}
